#!/usr/bin/env node
// cc-voice — Claude Code voice hook with per-event phrases, overrides, caching, and fallbacks.

import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import crypto from "node:crypto";
import { execSync } from "node:child_process";
import { fileURLToPath } from "node:url";

// ---------- read hook payload ----------
let payload = {};
try {
  const raw = fs.readFileSync(0, "utf8");
  payload = raw ? JSON.parse(raw) : {};
} catch (_) {
  payload = {};
}

// ---------- derive event context ----------
const name = payload.hook_event_name || "Unknown";
const tool = payload.tool_name || "";
const desc =
  payload?.tool_input?.description ||
  payload?.message ||
  "";
const toolInput = payload?.tool_input || {};
const toolResponse = payload?.tool_response || {};
const isPreEvent = name === "PreToolUse";
const isPostEvent = name === "PostToolUse";

// ---------- smart context detection ----------
function detectContext() {
  const descLower = desc.toLowerCase();
  const command = toolInput?.command || "";
  const commandLower = command.toLowerCase();

  // Git operations - check command first, then description
  if (tool === "Bash") {
    // Git commit
    if (commandLower.includes("git commit") || descLower.includes("git commit") || descLower.includes("committing")) {
      return isPreEvent ? "Committing changes to repository" : "Code committed to repository";
    }
    // Git push
    if (commandLower.includes("git push") || descLower.includes("git push") || descLower.includes("pushing")) {
      return isPreEvent ? "Pushing to remote repository" : "Changes pushed to remote";
    }
    // Git pull
    if (commandLower.includes("git pull") || descLower.includes("git pull") || descLower.includes("pulling")) {
      return isPreEvent ? "Pulling from remote repository" : "Repository synchronized";
    }
    // Git status/diff/log (read operations)
    if (commandLower.match(/git\s+(status|diff|log|show)/)) {
      return isPreEvent ? "Querying repository status" : "Repository query complete";
    }
    // Git add
    if (commandLower.includes("git add")) {
      return isPreEvent ? "Staging changes" : "Changes staged";
    }
  }

  // Test execution
  if (tool === "Bash" && (commandLower.match(/\b(npm|yarn|bun|pnpm)\s+(test|t)\b/) ||
      commandLower.match(/\b(pytest|jest|vitest|mocha|cargo test)\b/) ||
      descLower.includes("test"))) {
    if (isPostEvent) {
      // Check for failure indicators in output
      const output = String(toolResponse?.output || "");
      if (output.match(/\bfail(ed|ure|s)?\b/i) || output.includes("✗") || output.includes("×")) {
        return "Test suite execution complete. Failures detected";
      }
      return "Test suite execution complete. All tests passed";
    }
    return "Initiating test suite execution";
  }

  // Build operations
  if (tool === "Bash" && (commandLower.match(/\b(npm|yarn|bun|pnpm)\s+(run\s+)?build\b/) ||
      commandLower.match(/\b(make|cargo build|gradle build)\b/) ||
      descLower.includes("build"))) {
    if (isPostEvent) {
      const output = String(toolResponse?.output || "");
      if (output.match(/\berror\b/i) || output.match(/\bfail/i)) {
        return "Build failed. Review errors";
      }
      return "Build completed successfully";
    }
    return "Initiating build process";
  }

  // NPM/Package manager operations
  if (tool === "Bash") {
    if (commandLower.match(/\b(npm|yarn|bun|pnpm)\s+install\b/)) {
      return isPreEvent ? "Installing dependencies" : "Dependencies installed";
    }
    if (commandLower.match(/\b(npm|yarn|bun|pnpm)\s+run\s+(\w+)/)) {
      const script = commandLower.match(/\b(npm|yarn|bun|pnpm)\s+run\s+(\w+)/)?.[2];
      return isPreEvent ? `Running ${script} script` : `${script} script complete`;
    }
    if (commandLower.match(/\b(npm|yarn|bun)\s+start\b/)) {
      return isPreEvent ? "Starting development server" : "Server started";
    }
  }

  // Directory operations
  if (tool === "Bash") {
    if (commandLower.match(/\bpwd\b/)) {
      return isPreEvent ? "Checking current directory" : "Directory identified";
    }
    if (commandLower.match(/\bcd\s+/)) {
      return isPreEvent ? "Changing directory" : "Directory changed";
    }
    if (commandLower.match(/\b(ls|dir)\b/)) {
      return isPreEvent ? "Listing directory contents" : "Directory listing complete";
    }
    if (commandLower.match(/\bmkdir\b/)) {
      return isPreEvent ? "Creating directory" : "Directory created";
    }
  }

  // File operations
  if (tool === "Bash") {
    if (commandLower.match(/\b(cat|head|tail|less|more)\s+/)) {
      return isPreEvent ? "Reading file" : "File read complete";
    }
    if (commandLower.match(/\b(cp|copy)\s+/)) {
      return isPreEvent ? "Copying file" : "File copied";
    }
    if (commandLower.match(/\b(mv|move|ren|rename)\s+/)) {
      return isPreEvent ? "Moving file" : "File moved";
    }
    if (commandLower.match(/\b(rm|del|delete)\s+/)) {
      return isPreEvent ? "Removing file" : "File removed";
    }
    if (commandLower.match(/\btouch\b/)) {
      return isPreEvent ? "Creating file" : "File created";
    }
  }

  // Search operations (when using bash grep, not Grep tool)
  if (tool === "Bash") {
    if (commandLower.match(/\b(grep|rg|ag|ack)\s+/)) {
      return isPreEvent ? "Searching files" : "Search complete";
    }
    if (commandLower.match(/\bfind\s+/)) {
      return isPreEvent ? "Searching for files" : "File search complete";
    }
  }

  // Process operations
  if (tool === "Bash") {
    if (commandLower.match(/\b(ps|top|htop)\b/)) {
      return isPreEvent ? "Checking processes" : "Process list retrieved";
    }
    if (commandLower.match(/\bkill\b/)) {
      return isPreEvent ? "Terminating process" : "Process terminated";
    }
  }

  // Network operations
  if (tool === "Bash") {
    if (commandLower.match(/\b(curl|wget)\s+/)) {
      return isPreEvent ? "Fetching remote resource" : "Resource fetched";
    }
    if (commandLower.match(/\bping\s+/)) {
      return isPreEvent ? "Testing network connection" : "Network test complete";
    }
  }

  // System info
  if (tool === "Bash") {
    if (commandLower.match(/\b(which|whereis|type)\s+/)) {
      return isPreEvent ? "Locating command" : "Command located";
    }
    if (commandLower.match(/\b(env|printenv)\b/)) {
      return isPreEvent ? "Checking environment variables" : "Environment retrieved";
    }
    if (commandLower.match(/\b(chmod|chown)\s+/)) {
      return isPreEvent ? "Modifying permissions" : "Permissions updated";
    }
  }

  // Docker operations
  if (tool === "Bash") {
    if (commandLower.match(/\bdocker\s+(build|run|start|stop|ps|exec)/)) {
      const op = commandLower.match(/\bdocker\s+(build|run|start|stop|ps|exec)/)?.[1];
      return isPreEvent ? `Docker ${op} initiating` : `Docker ${op} complete`;
    }
  }

  return null;
}

// ---------- CLI/env overrides ----------
const argv = process.argv;
const argAt = (flag) => {
  const i = argv.indexOf(flag);
  return i >= 0 ? argv[i + 1] : undefined;
};

const phraseFromArgs = (() => {
  const i = argv.indexOf("--phrase");
  return i >= 0 ? argv.slice(i + 1).filter(t => !t.startsWith("--")).join(" ").trim() : "";
})();

const phraseFromEnv = process.env.VOICE_PHRASE || "";
const voiceFromArgs = argAt("--voice-id") || "";
const modelFromArgs = argAt("--model-id") || "";
const playbackFromArgs = argAt("--player") || ""; // "afplay" | "say" | "ffplay" | "pwsh"

// ---------- tool-specific phrases ----------
function getToolPhrase() {
  // Check for smart context first
  const contextPhrase = detectContext();
  if (contextPhrase) return contextPhrase;

  // Tool-specific phrases
  if (tool === "Edit" || tool === "MultiEdit" || tool === "Write") {
    return isPreEvent ? `Initiating ${tool} operation` : `File ${tool === "Write" ? "created" : "modified"} successfully`;
  }
  if (tool === "Read") {
    return isPreEvent ? "Retrieving file contents" : "File retrieved and analyzed";
  }
  if (tool === "Bash") {
    return isPreEvent ? "Executing command" : "Command executed successfully";
  }
  if (tool === "Grep" || tool === "Glob") {
    return isPreEvent ? "Searching codebase" : "Search complete";
  }
  if (tool === "Task") {
    const subagentType = toolInput?.subagent_type || "";
    if (subagentType) {
      // Convert kebab-case or snake_case to readable format
      const readableType = subagentType
        .replace(/[-_]/g, " ")
        .replace(/\b\w/g, l => l.toUpperCase());
      return isPreEvent
        ? `Launching ${readableType} agent`
        : `${readableType} agent task completed`;
    }
    return isPreEvent ? "Launching specialized agent" : "Agent task completed";
  }

  return null;
}

// ---------- default event phrases ----------
const autoText = (() => {
  if (name === "Stop") return "Response cycle concluded. Awaiting further instruction.";
  if (name === "SubagentStop") return "Auxiliary module has completed its assignment. Systems standing by.";
  if (name === "Notification") return desc || "Your immediate attention is required. A situation awaits your command.";
  if (name === "PreToolUse" || name === "PostToolUse") {
    const toolPhrase = getToolPhrase();
    if (toolPhrase) return toolPhrase;
    return `${tool || "Tool"} ${isPreEvent ? "initiating" : "completed"}`;
  }
  return `Event ${name} detected.`;
})();

// ---------- final phrase ----------
const text = (phraseFromArgs || phraseFromEnv || autoText).trim();

// ---------- ElevenLabs config ----------
const apiKey = process.env.ELEVENLABS_API_KEY || "";

// Voice selection based on event type and context
function selectVoice() {
  if (voiceFromArgs) return voiceFromArgs;

  const contextPhrase = detectContext();

  // Error/failure voice (more serious tone)
  if (contextPhrase && (contextPhrase.includes("fail") || contextPhrase.includes("error"))) {
    return process.env.ELEVENLABS_VOICE_ERROR || "pNInz6obpgDQGcFmaJgB"; // Adam (serious)
  }

  // Success voice (confident tone)
  if (isPostEvent && !contextPhrase?.includes("fail")) {
    return process.env.ELEVENLABS_VOICE_SUCCESS || "ZwQsH4li5bkOUTP3m3d1"; // default
  }

  // PreToolUse voice (slightly different for variety)
  if (isPreEvent) {
    return process.env.ELEVENLABS_VOICE_PRE || "ZwQsH4li5bkOUTP3m3d1";
  }

  // Notification voice (alert tone)
  if (name === "Notification") {
    return process.env.ELEVENLABS_VOICE_ALERT || "EXAVITQu4vr4xnSDxMaL"; // Bella (urgent)
  }

  return "ZwQsH4li5bkOUTP3m3d1";
}

const voice = selectVoice();
const model = modelFromArgs || process.env.ELEVENLABS_MODEL_ID || "eleven_flash_v2_5";

// ---------- simple cache ----------
// Bundled voices directory (check installation location first, then repo location)
const homeDir = os.homedir();
const installedVoicesDir = path.join(homeDir, ".local", "share", "cc-voice", "voices");
const scriptPath = fileURLToPath(import.meta.url);
const scriptDir = path.dirname(scriptPath);
const repoVoicesDir = path.join(scriptDir, "..", "voices");

// Use installed voices if available, otherwise fall back to repo location (for development)
const bundledVoicesDir = fs.existsSync(installedVoicesDir) ? installedVoicesDir : repoVoicesDir;

// User cache directory in temp
const cacheDir = path.join(os.tmpdir(), "cc-voice-cache");
try { fs.mkdirSync(cacheDir, { recursive: true }); } catch {}

const cacheKey = crypto.createHash("sha1").update([text, voice, model].join("|")).digest("hex");
const cachePath = path.join(cacheDir, `${cacheKey}.mp3`);
const bundledPath = path.join(bundledVoicesDir, `${cacheKey}.mp3`);

// ---------- playback helpers ----------
function tryExec(cmd) {
  try { execSync(cmd, { stdio: "ignore" }); return true; } catch { return false; }
}

function detectPlatform() {
  const platform = os.platform();
  if (platform === "darwin") return "macos";
  if (platform === "win32") return "windows";
  return "linux";
}

function play(file) {
  const preferred = playbackFromArgs || process.env.CC_VOICE_PLAYER || "";
  const platform = detectPlatform();
  const tries = [];

  if (preferred) {
    if (preferred === "afplay") tries.push(`afplay "${file}"`);
    else if (preferred === "say") tries.push(`say -f "${file}"`);
    else if (preferred === "ffplay") tries.push(`ffplay -nodisp -autoexit -loglevel quiet "${file}"`);
    else if (preferred === "aplay") tries.push(`aplay -q "${file}"`);
    else if (preferred === "pwsh") tries.push(`powershell -NoProfile -Command "$player = New-Object System.Media.SoundPlayer '${file}'; $player.PlaySync()"`);
  }

  // Platform-specific fallback order
  if (platform === "macos") {
    tries.push(
      `afplay "${file}"`,
      `ffplay -nodisp -autoexit -loglevel quiet "${file}"`
    );
  } else if (platform === "windows") {
    // Windows: Use PowerShell MediaPlayer with explicit Play() call
    const winPath = file.replace(/\//g, '\\');
    tries.push(
      // PowerShell MediaPlayer - call Play() after Open()
      `powershell -NoProfile -WindowStyle Hidden -Command "Add-Type -AssemblyName PresentationCore; $m = New-Object System.Windows.Media.MediaPlayer; $m.Open('${winPath}'); $m.Play(); Start-Sleep -Milliseconds 1500"`,
      // Fallback: ffplay
      `ffplay -nodisp -autoexit -loglevel quiet "${file}"`
    );
  } else {
    // Linux
    tries.push(
      `aplay -q "${file}"`,
      `ffplay -nodisp -autoexit -loglevel quiet "${file}"`,
      `paplay "${file}"`
    );
  }

  for (const cmd of tries) {
    if (tryExec(cmd)) return true;
  }
  return false;
}

function speakText(phrase) {
  const platform = detectPlatform();
  const escaped = phrase.replace(/"/g, '\\"').replace(/'/g, "\\'");

  if (platform === "macos") {
    return tryExec(`say "${escaped}"`);
  } else if (platform === "windows") {
    const psCmd = `powershell -NoProfile -Command "Add-Type -AssemblyName System.Speech; $synth = New-Object System.Speech.Synthesis.SpeechSynthesizer; $synth.Speak('${escaped}');"`;
    return tryExec(psCmd);
  } else {
    // Linux - try espeak, then festival
    if (tryExec(`espeak "${escaped}"`)) return true;
    if (tryExec(`festival --tts <<< "${escaped}"`)) return true;
    return false;
  }
}

async function fetchTTS(phrase) {
  const url = `https://api.elevenlabs.io/v1/text-to-speech/${voice}`;
  const body = {
    text: phrase,
    model_id: model,
    // voice_settings optional; omit for defaults or add if you prefer:
    // voice_settings: { stability: 0.4, similarity_boost: 0.8 }
  };

  const resp = await fetch(url, {
    method: "POST",
    headers: {
      "xi-api-key": apiKey,
      "Content-Type": "application/json",
      "Accept": "audio/mpeg"
    },
    body: JSON.stringify(body)
  });

  if (!resp.ok) {
    const code = resp.status;
    // write a brief error to stderr for diagnosis, then signal caller to fallback
    console.error(`[cc-voice] ElevenLabs HTTP ${code}`);
    throw new Error(String(code));
  }
  const buf = Buffer.from(await resp.arrayBuffer());
  return buf;
}

async function main() {
  // if phrase is empty, avoid silent calls
  const phrase = text || "Notification.";

  // 1) try bundled voices first (pre-generated, no API key needed)
  if (fs.existsSync(bundledPath)) {
    const playSuccess = play(bundledPath);
    if (!playSuccess) {
      // fallback to system TTS if player chain fails
      if (!speakText(phrase)) {
        console.log(phrase);
      }
    }
    process.exit(0);
  }

  // 2) try user cache
  if (fs.existsSync(cachePath)) {
    const playSuccess = play(cachePath);
    if (!playSuccess) {
      // fallback to system TTS if player chain fails
      if (!speakText(phrase)) {
        console.log(phrase);
      }
    }
    process.exit(0);
  }

  // 3) ElevenLabs path if key exists (generate new voice)
  if (apiKey) {
    try {
      const audio = await fetchTTS(phrase);
      fs.writeFileSync(cachePath, audio);
      const playSuccess = play(cachePath);
      if (!playSuccess) {
        // fallback to system TTS if player chain fails
        if (!speakText(phrase)) {
          console.log(phrase);
        }
      }
      process.exit(0);
    } catch {
      // fall through to system TTS
    }
  }

  // 4) System TTS fallback
  if (!speakText(phrase)) {
    console.log(phrase);
  }
  process.exit(0);
}

main();
